
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Nowości w rdzeniu języka &#8212; Modern C++</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=cbef0915" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=3ee479438cf8b5e0d341"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'core-features';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="constexpr if (C++17)" href="constexpr-if.html" />
    <link rel="prev" title="Standardy ISO C++" href="cpp-standards.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.svg" class="logo__image only-light" alt="Modern C++ - Home"/>
    <script>document.write(`<img src="_static/logo.svg" class="logo__image only-dark" alt="Modern C++ - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="index.html">
                    Nowoczesny C++
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Modern C++ Core</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="cpp-standards.html">Standardy ISO C++</a></li>
<li class="toctree-l1 current active has-children"><a class="current reference internal" href="#">Nowości w rdzeniu języka</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="constexpr-if.html">constexpr if (C++17)</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="class-features.html">Klasy w C++11/17</a></li>
<li class="toctree-l1"><a class="reference internal" href="move.html">Semantyka przenoszenia</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda-expressions.html">Wyrażenia lambda</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="templates.html">Szablony</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="ctad.html">Dedukcja argumentów dla szablonów klas - CTAD (C++17)</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="constexpr.html">Programowanie na etapie kompilacji - constexpr</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Modern C++ Standard Library</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="smart-pointers.html">Inteligentne wskaźniki</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuples.html">Krotki w C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="string-view.html">Klasa std::string_view</a></li>
<li class="toctree-l1"><a class="reference internal" href="any.html">Klasa std::any</a></li>
<li class="toctree-l1"><a class="reference internal" href="optional.html">Klasa std::optional</a></li>
<li class="toctree-l1"><a class="reference internal" href="variant.html">Klasa std::variant</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/core-features.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Nowości w rdzeniu języka</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nowe-typy-danych-podstawowych">Nowe typy danych podstawowych</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#typy-calkowite-o-znanym-rozmiarze">Typy całkowite o znanym rozmiarze</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nullptr-uniwersalny-pusty-wskaznik">nullptr - uniwersalny pusty wskaźnik</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#raw-string-literals">Raw String Literals</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wsparcie-dla-unicode">Wsparcie dla Unicode</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#typy-lancuchowe">Typy łańcuchowe</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rozszerzone-typy-wyliczeniowe">Rozszerzone typy wyliczeniowe</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#std-underlying-type-t">std::underlying_type_t<enum></enum></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wyliczenia-silnie-typizowane-scoped-enumerations">Wyliczenia silnie typizowane - Scoped Enumerations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deklaracje-zmiennych-z-auto">Deklaracje zmiennych z auto</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iteracja-po-kontenerach-z-auto">Iteracja po kontenerach z auto</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mechanizm-dedukcji-typu-dla-auto">Mechanizm dedukcji typu dla auto</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skladnia-definicji-zmiennych-z-auto">Składnia definicji zmiennych z auto</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#petla-for-dla-zakresow-range-based-for">Pętla for dla zakresów - range-based for</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efektywna-wersja-range-based-for">Efektywna wersja range-based for</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#funkcje-std-begin-i-std-end">Funkcje std::begin() i std::end()</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iteracja-po-kontenerach-zdefiniowanych-przez-uzytkownika">Iteracja po kontenerach zdefiniowanych przez użytkownika</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skladnia-jednolitej-inicjalizacji">Składnia jednolitej inicjalizacji</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inicjalizacja-z-wykorzystaniem">Inicjalizacja z wykorzystaniem {}</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inicjalizacja-dla-agregatow">Inicjalizacja {} dla agregatów</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inicjalizacja-klas-struktur-nie-bedacych-agregatami">Inicjalizacja {} klas/struktur nie będących agregatami</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#konwersja-zawezajaca-typ">Konwersja zawężająca typ</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#listy-inicjalizacyjne">Listy inicjalizacyjne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#klasa-initializer-list-t">Klasa initializer_list&lt;T&gt;</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#listy-inicjalizacyjne-w-przeciazonych-konstruktorach">Listy inicjalizacyjne w przeciążonych konstruktorach</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#listy-inicjalizacyjne-a-dedukcja-typow">Listy inicjalizacyjne a dedukcja typów</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#slowo-kluczowe-decltype">Słowo kluczowe - decltype</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nowa-skladnia-deklaracji-funkcji">Nowa składnia deklaracji funkcji</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#automatyczna-dedukcja-typu-zwracanego-z-funkcji-c-14">Automatyczna dedukcja typu zwracanego z funkcji (C++14)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dedukcja-z-auto">Dedukcja z auto</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dedukcja-z-decltype-auto">Dedukcja z decltype(auto)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#structured-bindings-c-17">Structured bindings (C++17)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#typy-wiazan">Typy wiązań</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mechanizm-wiazania-structured-binding">Mechanizm wiązania structured binding</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kwalifikatory-dla-wiazan">Kwalifikatory dla wiązań</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#praktyczne-wykorzystanie-structured-bindings">Praktyczne wykorzystanie structured bindings</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#instrukcje-if-oraz-switch-z-sekcja-inicjujaca-c-17">Instrukcje if oraz switch z sekcją inicjującą (C++17)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#obiekty-tymczasowe-w-sekcji-inicjujacej">Obiekty tymczasowe w sekcji inicjującej</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#structured-bindings-i-if-z-sekcja-inicjujaca">Structured bindings i if z sekcją inicjującą</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="nowosci-w-rdzeniu-jezyka">
<h1>Nowości w rdzeniu języka<a class="headerlink" href="#nowosci-w-rdzeniu-jezyka" title="Link to this heading">#</a></h1>
<section id="nowe-typy-danych-podstawowych">
<h2>Nowe typy danych podstawowych<a class="headerlink" href="#nowe-typy-danych-podstawowych" title="Link to this heading">#</a></h2>
<p>C++11 wprowadza kilka nowych fundamentalnych typów danych:</p>
<ul>
<li><p>typ: <code class="docutils literal notranslate"><span class="pre">[unsigned|signed]</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">[int]</span></code></p>
<ul>
<li><p>Gwarancja minimum 64 bitów</p></li>
<li><p>Literał: <code class="docutils literal notranslate"><span class="pre">LL</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">123456789012345L</span><span class="n">L</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>typy dla znaków UTF16/UTF32: <code class="docutils literal notranslate"><span class="pre">char16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">char32_t</span></code></p></li>
<li><p>typ dla pustego wskaźnika <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>: <code class="docutils literal notranslate"><span class="pre">nullptr_t</span></code></p></li>
</ul>
</section>
<section id="typy-calkowite-o-znanym-rozmiarze">
<h2>Typy całkowite o znanym rozmiarze<a class="headerlink" href="#typy-calkowite-o-znanym-rozmiarze" title="Link to this heading">#</a></h2>
<p>W C++11 wprowadzono aliasy na typy całkowite o znanym rozmiarze:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int8_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int32_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> - typy całkowite ze znakiem</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code> - typy całkowite bez znaku</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">intptr_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uintptr_t</span></code> - typy całkowite dla wskaźników mogące przechować wskaźnik na <code class="docutils literal notranslate"><span class="pre">void</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">intmax_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uintmax_t</span></code> - największe typy całkowite dostępne w danej architekturze</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdint&gt;</span>

<span class="kt">int8_t</span><span class="w"> </span><span class="n">i8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">127</span><span class="p">;</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">ui16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">65535</span><span class="p">;</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2147483647</span><span class="p">;</span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">ui64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18446744073709551615ULL</span><span class="p">;</span>
<span class="kt">uintmax_t</span><span class="w"> </span><span class="n">umax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18446744073709551615ULL</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="nullptr-uniwersalny-pusty-wskaznik">
<h2>nullptr - uniwersalny pusty wskaźnik<a class="headerlink" href="#nullptr-uniwersalny-pusty-wskaznik" title="Link to this heading">#</a></h2>
<p>Nowe słowo kluczowe - <code class="docutils literal notranslate"><span class="pre">nullptr</span></code></p>
<ul class="simple">
<li><p>wartość dla wskaźników, które na nic nie wskazują (wartość <code class="docutils literal notranslate"><span class="pre">0</span></code>)</p></li>
<li><p>bardziej czytelny i bezpieczniejszy odpowiednik stałej <code class="docutils literal notranslate"><span class="pre">NULL/0</span></code></p></li>
<li><p>posiada zdefiniowany przez standard typ - <code class="docutils literal notranslate"><span class="pre">std::nullptr_t</span></code> (zdefiniowany w pliku nagłówkowym <code class="docutils literal notranslate"><span class="pre">&lt;cstddef&gt;</span></code>)</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="n">nullptr_t</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Deklaracja pustych zmiennych wskaźnikowych od C++11 powinna wyglądać:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span>
<span class="n">assert</span><span class="p">(</span><span class="n">ptr_1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="c1">// or</span>

<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr_2</span><span class="p">{};</span><span class="w"> </span><span class="c1">// p1 is set to 0</span>
<span class="n">assert</span><span class="p">(</span><span class="n">ptr_2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">nullptr</span></code> rozwiązuje problem z przeciążeniem funkcji przyjmujących jako argument wskaźnik lub typ całkowity:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="n">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// calls foo(int)</span>
<span class="n">foo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span><span class="w"> </span><span class="c1">// calls foo(int)</span>
<span class="n">foo</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span><span class="w"> </span><span class="c1">// compile-time error</span>


<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>

<span class="n">bar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// calls bar(int)</span>
<span class="n">bar</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span><span class="w"> </span><span class="c1">// calls bar(int) if NULL is 0, ambiguous if NULL is 0L</span>
<span class="n">bar</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span><span class="w"> </span><span class="c1">// calls bar(void*)</span>
</pre></div>
</div>
</section>
<section id="raw-string-literals">
<h2>Raw String Literals<a class="headerlink" href="#raw-string-literals" title="Link to this heading">#</a></h2>
<p>W C++11 możemy uniknąć specjalnego traktowania “znaków ucieczki” (<em>escape characters</em>) w literałach znakowych stosując tzw. “Raw String Literals”.</p>
<p>“Raw string” zaczyna się od <code class="docutils literal notranslate"><span class="pre">R&quot;(</span></code>, a kończy się <code class="docutils literal notranslate"><span class="pre">)&quot;</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">no_newlines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">\n\n</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">cmd</span><span class="p">{</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">cd &quot;C:\new folder\text&quot;</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">};</span>
</pre></div>
</div>
<p>Literały tekstowe mogą zawierać teraz kilka lini:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">with_newlines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">Line 1 of text...</span>
<span class="s">Line 2...</span>
<span class="s">Line 3</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Aby mieć możliwość umieszczenia sekwencji <code class="docutils literal notranslate"><span class="pre">)&quot;</span></code> w literale “raw string”, należy użyć sekwencji przestankowej <em>delim</em>. W rezultacie kompletna składnia literału “raw string” to: <code class="docutils literal notranslate"><span class="pre">R&quot;delim()delim&quot;</span></code>.</p>
<ul class="simple">
<li><p>sekwencja przestankowa może mieć długość do 16 znaków i nie może zawierać białych znaków (spacji itp.).</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">raw(</span><span class="s">a\</span>
<span class="s">b\nc()&quot;</span>
<span class="dl">)raw</span><span class="s">&quot;</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;a</span><span class="se">\\\n</span><span class="s">    b</span><span class="se">\\</span><span class="s">nc()</span><span class="se">\&quot;\n</span><span class="s">    &quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Literały “raw string” są szczególnie przydatne przy definiowaniu wyrażeń regularnych lub ścieżek w systemie Windows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">regex</span><span class="w"> </span><span class="n">re1</span><span class="p">(</span><span class="w"> </span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">!(</span><span class="s">&quot;operator\(\)&quot;|&quot;operator-&gt;&quot;</span><span class="dl">)!</span><span class="s">&quot;</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// &quot;operator()&quot;|&quot;operator-&gt;&quot;</span>
</pre></div>
</div>
</section>
<section id="wsparcie-dla-unicode">
<h2>Wsparcie dla Unicode<a class="headerlink" href="#wsparcie-dla-unicode" title="Link to this heading">#</a></h2>
<p>Od C++11 dozwolone są następujące literały znakowe:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">u8</span></code> - definiuje kodowanie UTF-8</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> - definiuje literał ze znakami <code class="docutils literal notranslate"><span class="pre">char16_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">U</span></code> - definiuje literał ze znakami <code class="docutils literal notranslate"><span class="pre">char32_t</span></code></p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="sa">u</span><span class="s">&quot;UTF-16 string literal&quot;</span><span class="w">  </span><span class="c1">// char16_t (UTF-16)</span>
<span class="sa">U</span><span class="s">&quot;UTF-32 string literal&quot;</span><span class="w">  </span><span class="c1">// char32_t (UTF-32)</span>
<span class="sa">u8</span><span class="s">&quot;UTF-8 string literal&quot;</span><span class="w">  </span><span class="c1">// char (UTF-8)</span>
</pre></div>
</div>
<p>Kody znaków są podawane w postaci <code class="docutils literal notranslate"><span class="pre">\unnnn</span></code> oraz <code class="docutils literal notranslate"><span class="pre">\Unnnnnnnn</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="sa">u8</span><span class="s">&quot;G clef: </span><span class="se">\U0001D11E</span><span class="s">&quot;</span>
<span class="sa">u</span><span class="s">&quot;Euro: </span><span class="se">\u0024</span><span class="s">&quot;</span>
<span class="sa">U</span><span class="s">&quot;Skull and bones: </span><span class="se">\u2620</span><span class="s">&quot;</span>
</pre></div>
</div>
<section id="typy-lancuchowe">
<h3>Typy łańcuchowe<a class="headerlink" href="#typy-lancuchowe" title="Link to this heading">#</a></h3>
<p>Standard definiuje cztery typy łańcuchowe:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::string</span></code> - specjalizacja szablonu <code class="docutils literal notranslate"><span class="pre">std::basic_string&lt;char&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::wstring</span></code> - specjalizacja szablonu <code class="docutils literal notranslate"><span class="pre">std::basic_string&lt;wchar_t&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::u16string</span></code> - specjalizacja szablonu <code class="docutils literal notranslate"><span class="pre">std::basic_string&lt;char16_t&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::u32string</span></code> - specjalizacja szablonu <code class="docutils literal notranslate"><span class="pre">std::basic_string&lt;char32_t&gt;</span></code></p></li>
</ul>
</section>
</section>
<section id="rozszerzone-typy-wyliczeniowe">
<h2>Rozszerzone typy wyliczeniowe<a class="headerlink" href="#rozszerzone-typy-wyliczeniowe" title="Link to this heading">#</a></h2>
<p>Dla typów wyliczeniowych można od C++11 specyfikować typ całkowity, na którym definiowane jest wyliczenie.</p>
<p>Wartości podawane w wyliczeniu muszą mieścić się w dozwolonym zakresie dla typu.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">Coffee</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">uint_8_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">espresso</span><span class="p">,</span><span class="w"> </span><span class="n">cappucino</span><span class="p">,</span><span class="w"> </span><span class="n">latte</span><span class="w"> </span><span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">opened</span><span class="p">,</span><span class="w"> </span><span class="n">closed</span><span class="p">,</span><span class="w"> </span><span class="n">unknown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// error!</span>
</pre></div>
</div>
<p>Typ na bazie którego definiowane jest wyliczenie jest dostępny za pomocą metafunkcji <code class="docutils literal notranslate"><span class="pre">std::underlying_type_t&lt;EnumType&gt;</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">Coffee</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">espresso</span><span class="p">,</span><span class="w"> </span><span class="n">cappuccino</span><span class="p">,</span><span class="w"> </span><span class="n">latte</span><span class="w"> </span><span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Coffee</span><span class="w"> </span><span class="n">coffee</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">espresso</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">Coffee</span><span class="o">&gt;&gt;</span><span class="p">)</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Underlying type is uint8_t</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="std-underlying-type-t">
<h3>std::underlying_type_t<Enum><a class="headerlink" href="#std-underlying-type-t" title="Link to this heading">#</a></h3>
<p>Funkcja <code class="docutils literal notranslate"><span class="pre">std::underlying_type_t&lt;Enum&gt;</span></code> zwraca typ całkowity, na którym zdefiniowane jest wyliczenie.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">red</span><span class="p">,</span><span class="w"> </span><span class="n">green</span><span class="p">,</span><span class="w"> </span><span class="n">blue</span><span class="w"> </span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;</span><span class="w"> </span><span class="n">int_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">green</span><span class="p">;</span><span class="w"> </span><span class="c1">// int_value : uint8_t</span>
<span class="n">asssert</span><span class="p">(</span><span class="n">int_value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>W C++23 wprowadzono funkcję <code class="docutils literal notranslate"><span class="pre">std::to_underlying</span></code>, która zwraca wartość wyliczenia w postaci typu całkowitego.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">int_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_underlying</span><span class="p">(</span><span class="n">Color</span><span class="o">::</span><span class="n">green</span><span class="p">);</span><span class="w"> </span><span class="c1">// int_value : uint8_t</span>
</pre></div>
</div>
<p>Jej implementacja jest bardzo prosta:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Enum</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">to_underlying</span><span class="p">(</span><span class="n">Enum</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="wyliczenia-silnie-typizowane-scoped-enumerations">
<h2>Wyliczenia silnie typizowane - Scoped Enumerations<a class="headerlink" href="#wyliczenia-silnie-typizowane-scoped-enumerations" title="Link to this heading">#</a></h2>
<p>Dla wyliczeń silnie typizowanych (<em>scoped enums</em>):</p>
<ul class="simple">
<li><p>można specyfikować na bazie jakiego typu definiowane jest wyliczenie</p>
<ul>
<li><p>domyślnym typem na którym definiowane jest wyliczenie jest <code class="docutils literal notranslate"><span class="pre">int</span></code></p></li>
</ul>
</li>
<li><p>niejawna konwersja do i z typu całkowitego nie jest dozwolona</p></li>
<li><p>nie ma możliwości porównania obiektów różnych typów wyliczeniowych</p></li>
<li><p>wartości wyliczenia są umieszczone w zakresie typu</p></li>
<li><p>istnieje możliwość użycia deklaracji zapowiadającej (<em>forward declaration</em>). Gdy używany jest tylko typ nie ma potrzeby rekompilacji przy dodaniu nowej wartości dla wyliczenia.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Engine</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span><span class="p">;</span><span class="w">  </span><span class="c1">// forward declaration</span>

<span class="n">Engine</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>

<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Engine</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">petrol</span><span class="p">,</span><span class="w"> </span><span class="n">diesel</span><span class="p">,</span><span class="w"> </span><span class="n">wankel</span><span class="w"> </span><span class="p">};</span>

<span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Engine</span><span class="o">::</span><span class="n">petrol</span><span class="p">;</span><span class="w"> </span><span class="c1">// OK</span>

<span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diesel</span><span class="p">;</span><span class="w">  </span><span class="c1">// error - no &quot;diesel&quot; in scope</span>

<span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// error</span>

<span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK: e == Engine::diesel</span>

<span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Engine</span><span class="o">::</span><span class="n">wankel</span><span class="p">;</span><span class="w"> </span><span class="c1">// error</span>

<span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">    </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">Engine</span><span class="o">::</span><span class="n">wankel</span><span class="p">);</span>
</pre></div>
</div>
<p>Zamiast <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> może być użyte <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">struct</span></code> - nie ma żadnej semantycznej różnicy między tymi formami.</p>
</section>
<section id="deklaracje-zmiennych-z-auto">
<h2>Deklaracje zmiennych z auto<a class="headerlink" href="#deklaracje-zmiennych-z-auto" title="Link to this heading">#</a></h2>
<p>Deklaracje zmiennych z użyciem słowa kluczowego <code class="docutils literal notranslate"><span class="pre">auto</span></code> umożliwiają automatyczną dedukcję typu zmiennej przez kompilator. Dedukcja typu odbywa się na podstawie inicjalizatora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">auto</span></code> jest słowem kluczowym, które w C++11 otrzymało nowe znaczenie</p></li>
<li><p>w poprzednich standardach oznaczało zmienną automatyczną (tworzoną na stosie) - praktycznie nigdy nie było używane</p></li>
</ul>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="c1">// i : int</span>

<span class="k">auto</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14f</span><span class="p">;</span><span class="w"> </span><span class="c1">// f : float</span>

<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spellcheck</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spellcheck</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="c1">// it : std::set&lt;std::string&gt;::iterator</span>
<span class="k">auto</span><span class="w"> </span><span class="n">const_it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spellcheck</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span><span class="w"> </span><span class="c1">// const_it : std::set&lt;std::string&gt;::const_iterator</span>
</pre></div>
</div>
<p>Definiując zmienną z użyciem <code class="docutils literal notranslate"><span class="pre">auto</span></code> można dodawać modyfikatory <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">volatile</span></code> oraz stosować referencje lub wskaźniki:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// i : int</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">*</span><span class="w"> </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// ptr1 : const int*</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// ptr2 : int* const</span>

<span class="kt">double</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w">  </span><span class="c1">// r1 : double</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w">  </span><span class="c1">// r2: const double&amp;</span>

<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ref_spellcheck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spellcheck</span><span class="p">;</span><span class="w"> </span><span class="c1">// ref_spellcheck : const std::set&lt;std::string&gt;&amp;</span>
</pre></div>
</div>
<section id="iteracja-po-kontenerach-z-auto">
<h3>Iteracja po kontenerach z auto<a class="headerlink" href="#iteracja-po-kontenerach-z-auto" title="Link to this heading">#</a></h3>
<p>Używając <code class="docutils literal notranslate"><span class="pre">auto</span></code> można wygodnie iterować po kontenerach zlecając kompilatorowi dedukcję typu iteratora.</p>
<p>Aby uzyskać w trakcie iteracji <code class="docutils literal notranslate"><span class="pre">const_iterator</span></code> należy użyć nowych metod z interfejsu kontenerów standardowych <code class="docutils literal notranslate"><span class="pre">cbegin()</span></code> i <code class="docutils literal notranslate"><span class="pre">cend()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">do_something</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">do_something</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok - type of it - vector&lt;int&gt;::iterator</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok - type of it - vector&lt;int&gt;::const_iterator</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="mechanizm-dedukcji-typu-dla-auto">
<h3>Mechanizm dedukcji typu dla auto<a class="headerlink" href="#mechanizm-dedukcji-typu-dla-auto" title="Link to this heading">#</a></h3>
<p>Mechanizm dedukcji typu dla <code class="docutils literal notranslate"><span class="pre">auto</span></code> jest praktycznie taki sam jak dla parametrów szablonu.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">ParamType</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>

<span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span><span class="w"> </span><span class="c1">// dedukcja typu t na podstawie wyrażenia</span>
<span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr</span><span class="p">;</span><span class="w"> </span><span class="c1">// praktycznie ten sam mechanizm dedukcji typu</span>
</pre></div>
</div>
<p>W mechanizmie automatycznej dedukcji typów specyfikator typu <code class="docutils literal notranslate"><span class="pre">auto</span></code> jest odpowiednikiem <code class="docutils literal notranslate"><span class="pre">ParamType</span></code> w mechanizmie dedukcji typów dla szablonów.</p>
<p>Możemy wyróżnić trzy zasadnicze przypadki:</p>
<ol class="arabic">
<li><p>Specyfikator typu nie jest ani referencją ani wskaźnikiem.</p>
<ul class="simple">
<li><p>jeśli wyrażenie inicjujące jest referencją - referencja jest usuwana</p></li>
<li><p>ignorowane są modyfikatory <code class="docutils literal notranslate"><span class="pre">const</span></code> i <code class="docutils literal notranslate"><span class="pre">volatile</span></code></p></li>
<li><p>tablice i funkcje rozpadają się do wskaźników (<em>decay to pointers</em>)</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">665</span><span class="p">;</span>
<span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ref_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cref_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">      </span><span class="c1">// a1 : int</span>
<span class="k">auto</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="w">      </span><span class="c1">// a2 : int - const is stripped</span>
<span class="k">auto</span><span class="w"> </span><span class="n">a3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref_x</span><span class="p">;</span><span class="w">  </span><span class="c1">// a3 : int - reference is stripped</span>
<span class="k">auto</span><span class="w"> </span><span class="n">a4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cref_x</span><span class="p">;</span><span class="w"> </span><span class="c1">// a4 : int - reference and const are stripped</span>

<span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w">  </span>
<span class="k">auto</span><span class="w"> </span><span class="n">a5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">   </span><span class="c1">// a5 : int* - array decays to pointer</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">a6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w">    </span><span class="c1">// a6 : int(*)() - function decays to pointer</span>
</pre></div>
</div>
</li>
<li><p>Specyfikator typu jest referencją lub wskaźnikiem.</p>
<ul class="simple">
<li><p>zachowywane są referencje oraz modyfikatory <code class="docutils literal notranslate"><span class="pre">const</span></code> i <code class="docutils literal notranslate"><span class="pre">volatile</span></code></p></li>
<li><p>tablice i funkcje nie rozpadają się do wskaźników</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">665</span><span class="p">;</span>
<span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ref_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cref_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">      </span><span class="c1">// a1 : int&amp;</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cx</span><span class="p">;</span><span class="w">     </span><span class="c1">// a2 : const int&amp;</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref_x</span><span class="p">;</span><span class="w">  </span><span class="c1">// a3 : int&amp;</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cref_x</span><span class="p">;</span><span class="w"> </span><span class="c1">// a4 : const int&amp;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w">  </span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">   </span><span class="c1">// a5 : int(&amp;)[10]</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w">    </span><span class="c1">// a6 : int(&amp;)()</span>
</pre></div>
</div>
</li>
<li><p>Specyfikator typu jest “uniwersalną referencją”</p>
<ul class="simple">
<li><p>jeśli wyrażenie inicjujące jest <code class="docutils literal notranslate"><span class="pre">l-value</span></code> następuje dedukcja to referencji <code class="docutils literal notranslate"><span class="pre">l-value</span></code></p></li>
<li><p>jeśli wyrażenie inicjujące jest <code class="docutils literal notranslate"><span class="pre">r-value</span></code> następuje dedukcja to referencji <code class="docutils literal notranslate"><span class="pre">r-value</span></code></p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>

<span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ax1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">   </span><span class="c1">// ax1 : int&amp;</span>

<span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ax2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">  </span><span class="c1">// ax2 : int&amp;&amp;</span>
</pre></div>
</div>
</li>
</ol>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Jedyna różnica między mechanizmem dedukcji typu w szablonach a w <code class="docutils literal notranslate"><span class="pre">auto</span></code> dotyczy<br />
dedukcji typu z listy inicjalizacyjnej zdefiniowanej za pomocą nawiasów klamrowych <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3</span> <span class="pre">}</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// items : std::initializer_list&lt;int&gt;</span>
</pre></div>
</div>
</div>
</section>
<section id="skladnia-definicji-zmiennych-z-auto">
<h3>Składnia definicji zmiennych z auto<a class="headerlink" href="#skladnia-definicji-zmiennych-z-auto" title="Link to this heading">#</a></h3>
<p>Dozwolone są dwie składnie inicjalizacji:</p>
<ul class="simple">
<li><p>składnia bezpośredniej inicjalizacji</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">var1(expr);</span></code></p></li>
<li><p>lub <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">var1{expr};</span></code></p></li>
</ul>
</li>
<li><p>składnia kopiująca - <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">var2</span> <span class="pre">=</span> <span class="pre">expr;</span></code></p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// direct initialization syntax</span>
<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// b : int</span>
<span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="p">{</span><span class="n">i</span><span class="p">};</span><span class="w"> </span><span class="c1">// c : int - since C++17</span>
<span class="k">auto</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">i</span><span class="p">};</span><span class="w"> </span><span class="c1">// d : compiler error since C++17</span>
</pre></div>
</div>
<p><strong>Obie składnie mają takie samo znaczenie w kontekście dedukcji typów.</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Jeśli typ dedukowany ma konstruktor kopiujący zdefiniowany jako <code class="docutils literal notranslate"><span class="pre">explicit</span></code>, to kompiluje się tylko składnia bezpośrednia.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// copy initialization syntax</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Expl</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Expl</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">Expl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Expl</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="n">Expl</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="c1">// compile error</span>
<span class="k">auto</span><span class="w"> </span><span class="n">a2</span><span class="p">{</span><span class="n">e</span><span class="p">};</span><span class="w"> </span><span class="c1">// OK</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="petla-for-dla-zakresow-range-based-for">
<h2>Pętla for dla zakresów - range-based for<a class="headerlink" href="#petla-for-dla-zakresow-range-based-for" title="Link to this heading">#</a></h2>
<p>Pętla <em>range-based for</em> iteruje po wszystkich elementach zakresu.</p>
<p>Wyrażenie</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="k">for</span><span class="o">-</span><span class="n">range</span><span class="o">-</span><span class="n">declaration</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">for</span><span class="o">-</span><span class="n">range</span><span class="o">-</span><span class="n">initializer</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">statement</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>jest rozwijane do pętli:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">__range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="o">-</span><span class="n">range</span><span class="o">-</span><span class="n">initializer</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">__begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="o">-</span><span class="n">expr</span><span class="w"> </span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">__end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="o">-</span><span class="n">expr</span><span class="w"> </span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">__begin</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">__end</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">__begin</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="o">-</span><span class="n">range</span><span class="o">-</span><span class="n">declaration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">__begin</span><span class="p">;</span>
<span class="w">        </span><span class="n">statement</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Wyrażenie <code class="docutils literal notranslate"><span class="pre">begin-expr</span></code> i <code class="docutils literal notranslate"><span class="pre">end-expr</span></code> są ewaluowane do:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__range.begin()</span></code> i <code class="docutils literal notranslate"><span class="pre">__range.end()</span></code></p></li>
<li><p>lub z niższym priorytetem do <code class="docutils literal notranslate"><span class="pre">begin(__range)</span></code> i <code class="docutils literal notranslate"><span class="pre">end(__range)</span></code></p></li>
</ul>
<p>W praktyce pętla <em>range-based for</em> umożliwia wygodną iterację po:</p>
<ul class="simple">
<li><p>kontenerach standardowych:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vec</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>tablicach typu <em>C-style</em></p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>liście inicjalizacyjnej</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="mi">300</span><span class="p">,</span><span class="w"> </span><span class="mi">400</span><span class="p">})</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
</pre></div>
</div>
<section id="efektywna-wersja-range-based-for">
<h3>Efektywna wersja range-based for<a class="headerlink" href="#efektywna-wersja-range-based-for" title="Link to this heading">#</a></h3>
<p>Kopiowanie elementów w trakcie iteracji może obniżyć wydajność (np. dla typów <code class="docutils literal notranslate"><span class="pre">std::string</span></code>, <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code>) lub może być zabronione np. <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>. Można uniknąć kopiowania elementów w trakcie iteracji dodając referencję. Opcjonalnie można również stosować modyfikator <code class="docutils literal notranslate"><span class="pre">const</span></code> lub <code class="docutils literal notranslate"><span class="pre">volatile</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Gadget</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">shared_gadgets</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">shared_gadgets</span><span class="p">)</span>
<span class="w">    </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Gadget</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">unique_gadgets</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">unique_gadgets</span><span class="p">)</span><span class="w"> </span><span class="c1">// compilation error</span>
<span class="w">    </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>

<span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">unique_gadgets</span><span class="p">)</span><span class="w"> </span><span class="c1">// ok</span>
<span class="w">    </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="funkcje-std-begin-i-std-end">
<h3>Funkcje std::begin() i std::end()<a class="headerlink" href="#funkcje-std-begin-i-std-end" title="Link to this heading">#</a></h3>
<p>Funkcje wolne <code class="docutils literal notranslate"><span class="pre">std::begin()</span></code> oraz <code class="docutils literal notranslate"><span class="pre">std::end()</span></code> są częścią biblioteki standardowej C++11 i umożliwiają między innymi pętli <em>range-based for</em> iterację po tablicach natywnych (<em>C-array</em>).</p>
<p>Są zaprojektowane jako adaptery, które umożliwią iterację po kontenerach, które nie posiadają metod <code class="docutils literal notranslate"><span class="pre">begin()</span></code> i <code class="docutils literal notranslate"><span class="pre">end()</span></code>.</p>
<p>W bibliotece standardowej C++ są zdefiniowane dla:</p>
<ul>
<li><p>kontenerów standardowych</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Container</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">begin</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Container</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">end</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>tablic natywnych</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">begin</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">end</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Możliwe jest również zdefiniowanie własnych funkcji <code class="docutils literal notranslate"><span class="pre">begin()</span></code> i <code class="docutils literal notranslate"><span class="pre">end()</span></code> dla własnych kontenerów, które nie posiadają metod <code class="docutils literal notranslate"><span class="pre">begin()</span></code> i <code class="docutils literal notranslate"><span class="pre">end()</span></code>.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Pisząc kod generyczny dla kontenerów warto zawsze używać <code class="docutils literal notranslate"><span class="pre">std::begin()</span></code> i <code class="docutils literal notranslate"><span class="pre">std::end()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TContainer</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TValue</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">find_value</span><span class="p">(</span><span class="n">TContainer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cont</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TValue</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">cont</span><span class="p">),</span><span class="w"> </span><span class="n">end</span><span class="p">(</span><span class="n">cont</span><span class="p">),</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="iteracja-po-kontenerach-zdefiniowanych-przez-uzytkownika">
<h3>Iteracja po kontenerach zdefiniowanych przez użytkownika<a class="headerlink" href="#iteracja-po-kontenerach-zdefiniowanych-przez-uzytkownika" title="Link to this heading">#</a></h3>
<p>Iteracja po kontenerach zdefiniowanych przez użytkownika wymaga zdefiniowania odpowiednich funkcji składowych <code class="docutils literal notranslate"><span class="pre">begin()</span></code> i <code class="docutils literal notranslate"><span class="pre">end()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">SomeContainer</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">SomeContainer</span><span class="w"> </span><span class="n">container</span><span class="p">;</span>

<span class="c1">// we can iterate over the container</span>
<span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">container</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pos_of_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_value</span><span class="p">(</span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">pos_of_3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>Można też utworzyć własne implementacje funkcji <code class="docutils literal notranslate"><span class="pre">begin()</span></code> i <code class="docutils literal notranslate"><span class="pre">end()</span></code> adaptując struktury danych, które nie posiadają tych metod.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">Custom</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">OtherContainer</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">begin</span><span class="p">(</span><span class="n">OtherContainer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">container</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">end</span><span class="p">(</span><span class="n">OtherContainer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">container</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">Custom</span><span class="o">::</span><span class="n">OtherContainer</span><span class="w"> </span><span class="n">container</span><span class="p">;</span>

<span class="c1">// we can iterate over the container</span>
<span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">container</span><span class="p">)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pos_of_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_value</span><span class="p">(</span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">pos_of_3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="skladnia-jednolitej-inicjalizacji">
<h2>Składnia jednolitej inicjalizacji<a class="headerlink" href="#skladnia-jednolitej-inicjalizacji" title="Link to this heading">#</a></h2>
<p>Motywacją dla wprowadzenia składni jednolitej inicjalizacji, był fakt, że inicjalizacja w C++98 stwarzała programistom wiele problemów.</p>
<p>Przykłady problemów w C++98:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// undefined value</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">var1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// &quot;direct initialization&quot; - from C++98</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">var2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// &quot;copy initialization&quot; - from C</span>

<span class="kt">int</span><span class="w"> </span><span class="n">var3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">();</span><span class="w"> </span><span class="c1">// var3 becomes 0 - from C++98</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">var4</span><span class="p">();</span><span class="w"> </span><span class="c1">// function declaration!!!</span>

<span class="kt">int</span><span class="w"> </span><span class="n">values</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// brace initialization of arrays</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w">   </span><span class="c1">// aggregate</span>
<span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="n">pt1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// brace initialization for aggregates</span>

<span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// initialization of classes</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cities</span><span class="p">;</span><span class="w"> </span><span class="c1">// no initialization for list of values</span>
<span class="n">cities</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Warsaw&quot;</span><span class="p">);</span>
<span class="n">cities</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Cracow&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Cele jednolitej inicjalizacji w C++11:</p>
<ul class="simple">
<li><p>jeden uniwersalny sposób inicjalizacji danych</p></li>
<li><p>powinna istnieć możliwość inicjalizacji kontenerów standardowych</p></li>
<li><p>powinna zabraniać inicjalizacji z wykorzystaniem zawężających konwersji</p></li>
</ul>
<p>Składnia jednolitej inicjalizacji jest rozszerzeniem standardu. Prawie cały kod wykorzystujący składnię C++98 jest wciąż poprawny. Jedyny wyjątek od tej reguły - niejawna konwersja, która zawęża typ.</p>
<section id="inicjalizacja-z-wykorzystaniem">
<h3>Inicjalizacja z wykorzystaniem {}<a class="headerlink" href="#inicjalizacja-z-wykorzystaniem" title="Link to this heading">#</a></h3>
<p>Składnia inicjalizacji z wykorzystaniem nawiasów klamrowych jest teraz dozwolona we wszystkich przypadkach:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// undefined value - still possible!!!</span>

<span class="kt">int</span><span class="w"> </span><span class="n">var1</span><span class="p">{</span><span class="mi">5</span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">var2</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="n">arr1</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">var1</span><span class="p">,</span><span class="w"> </span><span class="n">var1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">var2</span><span class="w"> </span><span class="p">};</span>

<span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="n">pt1</span><span class="p">{</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">{</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="p">};</span>

<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;Wroclaw&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cracow&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="p">}</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>Składni z klamrami można używać do inicjalizacji pól na liście inicjalizacyjnej konstruktora oraz do inicjalizacji tablic dynamicznych.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Data</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id_gen_</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Data</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">id_</span><span class="p">{</span><span class="o">++</span><span class="n">id_gen_</span><span class="p">},</span><span class="w"> </span><span class="n">data_</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">},</span><span class="w"> </span><span class="n">names_</span><span class="p">{</span><span class="s">&quot;Jan&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Adam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ewa&quot;</span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id_</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data_</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">names_</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">var1</span><span class="p">,</span><span class="w"> </span><span class="n">var2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
</section>
<section id="inicjalizacja-dla-agregatow">
<h3>Inicjalizacja {} dla agregatów<a class="headerlink" href="#inicjalizacja-dla-agregatow" title="Link to this heading">#</a></h3>
<p>Inicjalizacja agregatów za pomocą klamer przebiega dokładnie w ten sam sposób jak w C++98 i powoduje inicjalizację składowych wg kolejności ich definicji w agregacie. Liczba elementów na liście musi być równa lub mniejsza ilości elementów w agregacie.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"> </span><span class="c1">// [0, 0, 0]</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// [1, 2, 0]</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// [1, 2, 3]</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// error</span>
</pre></div>
</div>
</section>
<section id="inicjalizacja-klas-struktur-nie-bedacych-agregatami">
<h3>Inicjalizacja {} klas/struktur nie będących agregatami<a class="headerlink" href="#inicjalizacja-klas-struktur-nie-bedacych-agregatami" title="Link to this heading">#</a></h3>
<p>Inicjalizacja {} klas/struktur nie będących agregatami powoduje wywołanie odpowiedniego konstruktora.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Vector2D</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Vector2D</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x_</span><span class="p">{</span><span class="n">x</span><span class="p">},</span><span class="w"> </span><span class="n">y_</span><span class="p">{</span><span class="n">y</span><span class="p">}</span>
<span class="w">    </span><span class="p">{}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x_</span><span class="p">,</span><span class="w"> </span><span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Vector2D</span><span class="w"> </span><span class="n">vec1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">};</span>
<span class="n">Vector2D</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">};</span>
<span class="n">Vector2D</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">56</span><span class="p">,</span><span class="w"> </span><span class="mi">33</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// Error! too many args</span>

<span class="n">Vector2D</span><span class="w"> </span><span class="nf">versor_x</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Składnia “kopiująca” <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">variable</span> <span class="pre">=</span> <span class="pre">expr</span></code> nie może wywołać konstruktora zdefiniowanego jako <code class="docutils literal notranslate"><span class="pre">explicit</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// error</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="mi">12</span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// OK</span>
</pre></div>
</div>
</section>
<section id="konwersja-zawezajaca-typ">
<h3>Konwersja zawężająca typ<a class="headerlink" href="#konwersja-zawezajaca-typ" title="Link to this heading">#</a></h3>
<p>C++11 nie zezwala na użycie w inicjalizacji klamrowej niejawnej konwersji, która może doprowadzić do zawężenia typu.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">arr1</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// OK in C++98; error in C++11</span>

<span class="kt">int</span><span class="w"> </span><span class="n">arr2</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">4.5</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// OK both in C++98 and C++11</span>

<span class="n">Vector2D</span><span class="w"> </span><span class="nf">vec1</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mf">5.5</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK</span>
<span class="n">Vector2D</span><span class="w"> </span><span class="n">vec2</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mf">5.5</span><span class="p">};</span><span class="w"> </span><span class="c1">// error - implicit narrowing</span>
</pre></div>
</div>
</section>
</section>
<section id="listy-inicjalizacyjne">
<h2>Listy inicjalizacyjne<a class="headerlink" href="#listy-inicjalizacyjne" title="Link to this heading">#</a></h2>
<p>Aby umożliwić inicjalizację kontenerów standardowych za pomocą składni z nawiasami klamrowymi C++11 wprowadza nowy typ - <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span><span class="w">  </span><span class="c1">// creates vector with items: [1, 2, 3]</span>

<span class="n">v</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">99</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">});</span>

<span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span><span class="w"> </span>
</pre></div>
</div>
<section id="klasa-initializer-list-t">
<h3>Klasa initializer_list&lt;T&gt;<a class="headerlink" href="#klasa-initializer-list-t" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Typ zdefiniowany w pliku <code class="docutils literal notranslate"><span class="pre">&lt;initializer_list&gt;</span></code></p>
<ul>
<li><p>plik ten jest dołączany przez inne pliki nagłówkowe (np. <code class="docutils literal notranslate"><span class="pre">&lt;utility&gt;</span></code>)</p></li>
</ul>
</li>
<li><p>Przechowuje elementy listy inicjalizującej w tablicy i implementuje ograniczony interfejs umożliwiający dostęp do elementów przy pomocy iteratorów:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">size()</span></code> - ilość elementów w tablicy</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">begin()</span></code> - wskaźnik (<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code>) do pierwszego elementu tablicy</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">end()</span></code> - wskaźnik (<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code>) wskazujący koniec zakresu</p></li>
</ul>
</li>
<li><p>Elementy listy inicjalizującej są niezmienne - <em>immutable</em></p></li>
</ul>
<p>Jako argument funkcji <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> powinien być przesyłany przez wartość:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;initializer_list&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">show_items</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">show_items</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
<p>Przykład użycia <code class="docutils literal notranslate"><span class="pre">initializer_list</span></code> w konstruktorze klasy:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Container</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Container</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items</span><span class="p">);</span><span class="w"> </span><span class="c1">//initializer-list constructor</span>
<span class="w">    </span><span class="o">~</span><span class="n">Container</span><span class="p">();</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">size_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">const_iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="p">;</span>

<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">items_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size_</span><span class="p">;</span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">items_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Container</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">items</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span>
<span class="w">    </span><span class="n">size_</span><span class="p">{</span><span class="n">items</span><span class="p">.</span><span class="n">size</span><span class="p">()},</span><span class="w"> </span>
<span class="w">    </span><span class="n">items_</span><span class="p">{</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">aligned_alloc</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="n">size_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)))}</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">try</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">items_</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="p">(...)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">items_</span><span class="p">);</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="n">y</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">Container</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Destroying container...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">items_</span><span class="p">,</span><span class="w"> </span><span class="n">items_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size_</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">items_</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// usage of container</span>
<span class="n">Container</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// OK</span>
<span class="n">Container</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.2</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// OK</span>
<span class="n">Container</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3.5</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// error - template parameter T can&#39;t be deduced</span>
</pre></div>
</div>
</section>
<section id="listy-inicjalizacyjne-w-przeciazonych-konstruktorach">
<h3>Listy inicjalizacyjne w przeciążonych konstruktorach<a class="headerlink" href="#listy-inicjalizacyjne-w-przeciazonych-konstruktorach" title="Link to this heading">#</a></h3>
<p>Jeśli klasa posiada wiele wersji konstruktora, przy wywołaniu konstruktora poprzez nawiasy klamrowe preferowany jest konstruktor z <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Gadget</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Gadget</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="n">Gadget</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">);</span>
<span class="w">    </span><span class="n">Gadget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">Gadget</span><span class="w"> </span><span class="n">g1</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// calls Gadget::Gadget(int, string)</span>
<span class="n">Gadget</span><span class="w"> </span><span class="n">g2</span><span class="w"> </span><span class="p">{</span><span class="mi">77</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">};</span><span class="w"> </span><span class="c1">// calls Gadget::Gadget(int, string)</span>
<span class="n">Gadget</span><span class="w"> </span><span class="n">g3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">77</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">};</span><span class="w"> </span><span class="c1">// calls Gadget::Gadget(int, string)</span>

<span class="n">Gadget</span><span class="w"> </span><span class="nf">g5</span><span class="p">(</span><span class="mi">33</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">);</span><span class="w">  </span><span class="c1">// calls Gadget::Gadget(int, int)</span>
<span class="n">Gadget</span><span class="w"> </span><span class="n">g6</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">33</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// calls Gadget::Gadget(initializer_list)</span>
<span class="n">Gadget</span><span class="w"> </span><span class="n">g7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">33</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// calls Gadget::Gadget(initializer_list)</span>

<span class="k">auto</span><span class="w"> </span><span class="n">il</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">77</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">};</span><span class="w"> </span><span class="c1">// error - no initializer list deductable</span>
<span class="k">auto</span><span class="w"> </span><span class="n">il</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">77</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// OK - initializer_list&lt;int&gt; deduced</span>
<span class="n">Gadget</span><span class="w"> </span><span class="nf">g8</span><span class="p">(</span><span class="n">il</span><span class="p">);</span><span class="w">  </span><span class="c1">// calls Gadget::Gadget(initializer_list)</span>

<span class="n">Gadget</span><span class="w"> </span><span class="n">g9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w">   </span><span class="c1">// calls Gadget::Gadget(initializer_list)</span>
<span class="w">                  </span><span class="c1">// or calls default constructor if exists</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Reguła wywołań konstruktorów:</p>
<ul class="simple">
<li><p>() - inicjalizacja wywołuje normalne konstruktory</p></li>
<li><p>{} - inicjalizacja wywołuje również konstruktory z listą inicjalizacyjną</p>
<ul>
<li><p>konstruktory z <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> maję wyższy priorytet</p></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="listy-inicjalizacyjne-a-dedukcja-typow">
<h3>Listy inicjalizacyjne a dedukcja typów<a class="headerlink" href="#listy-inicjalizacyjne-a-dedukcja-typow" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> jest jedynym wyjątkiem różniącym dedukcję typów <code class="docutils literal notranslate"><span class="pre">auto</span></code> od dedukcji typów w szablonach:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// items is std::initializer_list&lt;int&gt;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="n">foo</span><span class="p">({</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// error - deduction failed</span>
</pre></div>
</div>
</section>
</section>
<section id="slowo-kluczowe-decltype">
<h2>Słowo kluczowe - decltype<a class="headerlink" href="#slowo-kluczowe-decltype" title="Link to this heading">#</a></h2>
<p>Słowo kluczowe <code class="docutils literal notranslate"><span class="pre">decltype</span></code> umożliwia kompilatorowi określenie typu dla podanego jako argument obiektu lub wyrażenia.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">math_dict</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;pi&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;e&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">2.71</span><span class="p">}</span><span class="w"> </span><span class="p">};</span>

<span class="k">decltype</span><span class="p">(</span><span class="n">math_dict</span><span class="p">)</span><span class="w"> </span><span class="n">other_dict</span><span class="p">;</span><span class="w"> </span><span class="c1">// other_dict has the same type as math_dict</span>

<span class="k">using</span><span class="w"> </span><span class="n">TEntry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">math_dict</span><span class="p">)</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span><span class="w"> </span><span class="c1">// TEntry is std::pair&lt;const std::string, double&gt;</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">TEntry</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>Jeżeli podajemy jako argument wywołania <code class="docutils literal notranslate"><span class="pre">decltype()</span></code> wyrażenie, to nie jest ono ewaluowane.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dict_numbers</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;sizeof: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">dict_numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints 8</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">dict_numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&gt;</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">dict_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="nowa-skladnia-deklaracji-funkcji">
<h2>Nowa składnia deklaracji funkcji<a class="headerlink" href="#nowa-skladnia-deklaracji-funkcji" title="Link to this heading">#</a></h2>
<p>Nowa alternatywna składnia deklaracji funkcji pozwala deklarować typ zwracany po liście parametrów funkcji.</p>
<p>Pozwala to na specyfikację zwracanego typu wewnątrz funkcji oraz z użyciem argumentów funkcji.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">multiply</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">auto</span><span class="w"> </span><span class="n">multiply</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>W połączeniu z <code class="docutils literal notranslate"><span class="pre">decltype</span></code> umożliwia specyfikację typu na podstawie wyrażenia wykorzystującego argumenty funkcji:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">multiply</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="automatyczna-dedukcja-typu-zwracanego-z-funkcji-c-14">
<h2>Automatyczna dedukcja typu zwracanego z funkcji (C++14)<a class="headerlink" href="#automatyczna-dedukcja-typu-zwracanego-z-funkcji-c-14" title="Link to this heading">#</a></h2>
<section id="dedukcja-z-auto">
<h3>Dedukcja z auto<a class="headerlink" href="#dedukcja-z-auto" title="Link to this heading">#</a></h3>
<p>W C++14 typ zwracany z funkcji może być automatycznie dedukowany z implementacji funkcji. Mechanizm dedukcji jest taki sam jak mechanizm automatycznej dedukcji typów zmiennych.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">multiply</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Jeśli w funkcji występuje wiele instrukcji <code class="docutils literal notranslate"><span class="pre">return</span></code> muszą one wszystkie zwracać wartości tego samego typu.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">get_name</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Gadget&quot;</span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;SuperGadget&quot;</span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="s">&quot;Unknown&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Rekurencja dla funkcji z <code class="docutils literal notranslate"><span class="pre">auto</span></code> jest możliwa, o ile rekurencyjne wywołanie następuje po przynajmniej jednym wywołaniu <code class="docutils literal notranslate"><span class="pre">return</span></code> zwracającego wartość nierekurencyjną.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="dedukcja-z-decltype-auto">
<h3>Dedukcja z decltype(auto)<a class="headerlink" href="#dedukcja-z-decltype-auto" title="Link to this heading">#</a></h3>
<p>Deklaracja <code class="docutils literal notranslate"><span class="pre">decltype(auto)</span></code> jako typu zwracanego z funkcji powoduje zastosowanie do dedukcji typu mechanizmu <code class="docutils literal notranslate"><span class="pre">decltype</span></code> (zachowującego referencje i modyfikatory <code class="docutils literal notranslate"><span class="pre">const</span></code> oraz <code class="docutils literal notranslate"><span class="pre">volatile</span></code>) zamiast mechanizmu <code class="docutils literal notranslate"><span class="pre">auto</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Fun</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="n">call_wrapper</span><span class="p">(</span><span class="n">Fun</span><span class="w"> </span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fun</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mechanizm <code class="docutils literal notranslate"><span class="pre">decltype</span></code> może być również używany do deklaracji zmiennych:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="kt">int</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span>

<span class="k">auto</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">              </span><span class="c1">// a1: int</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">d1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">       </span><span class="c1">// d1: int</span>
<span class="k">auto</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">            </span><span class="c1">// a2: int</span>
<span class="k">decltype</span><span class="p">((</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="n">d2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">   </span><span class="c1">// d2: int&amp;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">a3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w">            </span><span class="c1">// a3: int</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">())</span><span class="w"> </span><span class="n">d3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w">   </span><span class="c1">// d3: int&amp;&amp;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Gadget</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>

<span class="n">Gadget</span><span class="w"> </span><span class="n">g</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="n">Gadget</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cref_g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">g1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cref_g</span><span class="p">;</span><span class="w"> </span><span class="c1">// auto type deduction: g1&#39;s type is Gadget</span>

<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="n">g2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cref_g</span><span class="p">;</span><span class="w">  </span><span class="c1">// decltype type deduction: g2&#39;s type is const Widget&amp;</span>
</pre></div>
</div>
</section>
</section>
<section id="structured-bindings-c-17">
<h2>Structured bindings (C++17)<a class="headerlink" href="#structured-bindings-c-17" title="Link to this heading">#</a></h2>
<p>W C++17 można zdefiniować i jednocześnie zainicjować wiele zmiennych przy pomocy tzw. <em>structured binding</em>.</p>
<p>Typy zmiennych są dedukowane za pomocą mechanizmu <code class="docutils literal notranslate"><span class="pre">auto</span></code>.</p>
<section id="typy-wiazan">
<h3>Typy wiązań<a class="headerlink" href="#typy-wiazan" title="Link to this heading">#</a></h3>
<p>Do realizacji wiązania mogą być użyte:</p>
<ol class="arabic">
<li><p>Wszystkie elementy tablicy</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">get_coord</span><span class="p">()</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">coords</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_coord</span><span class="p">();</span>
</pre></div>
</div>
</li>
<li><p>Wszystkie elementy krotki lub obiektu kompatybilnego typu (np. std::pair, std::array)</p>
<ul>
<li><p>std::tuple</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tpl</span><span class="p">(</span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Doe&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">first_name</span><span class="p">,</span><span class="w"> </span><span class="n">last_name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tpl</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">last_name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>std::pair</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">unique_numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">was_inserted</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unique_numbers</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">was_inserted</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w">        </span>
</pre></div>
</div>
</li>
<li><p>std::array</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_coord_3D</span><span class="p">();</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_coord_3D</span><span class="p">();</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_coord_3D</span><span class="p">();</span><span class="w"> </span><span class="c1">// ERROR - number of items doesn&#39;t fit</span>
</pre></div>
</div>
</li>
</ul>
<p>Takie wiązanie jest realizowane tylko jeśli <code class="docutils literal notranslate"><span class="pre">std::tuple_size&lt;E&gt;</span></code> jest typem kompletnym (<code class="docutils literal notranslate"><span class="pre">E</span></code> jest typem krotki lub kompatybilnego obiektu)</p>
</li>
<li><p>Wszystkie niestatyczne składowe obiektu klasy/struktury/unii</p>
<ul class="simple">
<li><p>wszystkie składowe muszą być publiczne i być bezpośrednio zdefiniowane w klasie/strukturze wiązanego obiektu lub w jego klasie bazowej</p></li>
<li><p>anonimowe unie nie są dozwolone</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Person</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">fn</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">ln</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//...</span>

<span class="n">Person</span><span class="w"> </span><span class="n">p</span><span class="p">{</span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Doe&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">};</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">first_name</span><span class="p">,</span><span class="w"> </span><span class="n">last_name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data1</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">first_name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">last_name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ol>
<p>Jeśli liczba zmiennych umieszczonych w nawiasach <code class="docutils literal notranslate"><span class="pre">[]</span></code> nie zgadza się z liczbą składowych obiektu zwróconego, kompilator zgłasza błąd.</p>
</section>
<section id="mechanizm-wiazania-structured-binding">
<h3>Mechanizm wiązania structured binding<a class="headerlink" href="#mechanizm-wiazania-structured-binding" title="Link to this heading">#</a></h3>
<p>Mechanizm działania wiązania <em>structured binding</em> wykorzystuje nową (anonimową) zmienną, a nowe identyfikatory wprowadzone w wiązaniu odwołują się do pól tej anonimowej zmiennej.</p>
<p>Kod wiązania:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Timestamp</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Timestamp</span><span class="w"> </span><span class="n">timestamp</span><span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">};</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">hours</span><span class="p">,</span><span class="w"> </span><span class="n">minutes</span><span class="p">,</span><span class="w"> </span><span class="n">seconds</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timestamp</span><span class="p">;</span>
</pre></div>
</div>
<p>Odpowiada koncepcyjnie:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timestamp</span><span class="p">;</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">hours</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">h</span><span class="p">;</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">minutes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">seconds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>
</pre></div>
</div>
<p>Obiekt <code class="docutils literal notranslate"><span class="pre">e</span></code> istnieje tak długo jak istnieją zdefiniowane do niego wiązania.</p>
</section>
<section id="kwalifikatory-dla-wiazan">
<h3>Kwalifikatory dla wiązań<a class="headerlink" href="#kwalifikatory-dla-wiazan" title="Link to this heading">#</a></h3>
<p>Deklaracje <em>structured bindings</em> mogą być dekorowane kwalifikatorami w postaci referencji, modyfikatorów <code class="docutils literal notranslate"><span class="pre">const</span></code> oraz <code class="docutils literal notranslate"><span class="pre">volatile</span></code>, <code class="docutils literal notranslate"><span class="pre">alignas</span></code>, przy czym dekoracja taka dotyczy całego anonimowego obiektu:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="w"> </span><span class="p">};</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// rx and ry refer to the elements in a</span>

<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// v and w have type const int, initialized by the elements of a</span>

<span class="k">alignas</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="k">auto</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// i and d refers to implicit entity, which is 16-byte aligned</span>
</pre></div>
</div>
</section>
<section id="praktyczne-wykorzystanie-structured-bindings">
<h3>Praktyczne wykorzystanie structured bindings<a class="headerlink" href="#praktyczne-wykorzystanie-structured-bindings" title="Link to this heading">#</a></h3>
<ol class="arabic">
<li><p><em>Structured bindings</em> umożliwiają wygodną iterację po mapach w C++17:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">math_dict</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;pi&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;e&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">2.71</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">math_dict</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; - &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>Inicjalizacja wielu wartości różnych typów na raz w instrukcji <code class="docutils literal notranslate"><span class="pre">for</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">begin</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; - &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="instrukcje-if-oraz-switch-z-sekcja-inicjujaca-c-17">
<h2>Instrukcje if oraz switch z sekcją inicjującą (C++17)<a class="headerlink" href="#instrukcje-if-oraz-switch-z-sekcja-inicjujaca-c-17" title="Link to this heading">#</a></h2>
<p>W C++17 wprowadzono dodatkową składnię dla instrukcji <code class="docutils literal notranslate"><span class="pre">if</span></code> oraz <code class="docutils literal notranslate"><span class="pre">switch</span></code> umożliwiającą zgrupowanie instrukcji inicjującej oraz sprawdzającej warunek.</p>
<p>Nowa (dodatkowa) składnia:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">init</span><span class="p">;</span><span class="w"> </span><span class="n">condition</span><span class="p">)</span><span class="w"> </span>
<span class="p">{}</span>

<span class="k">switch</span><span class="p">(</span><span class="n">init</span><span class="p">;</span><span class="w"> </span><span class="n">condition</span><span class="p">)</span>
<span class="p">{}</span>
</pre></div>
</div>
<p>W efekcie kod, który w C++98 wyglądał tak:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Status</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">status</span><span class="p">();</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Status</span><span class="o">::</span><span class="n">bad</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Gadget is broken(status=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">        </span>
<span class="p">}</span>
</pre></div>
</div>
<p>możemy zastąpić bardziej zwięzłym kodem:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Status</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">status</span><span class="p">();</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Status</span><span class="o">::</span><span class="n">bad</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Gadget is broken(status=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">        </span>
<span class="p">}</span>
</pre></div>
</div>
<p>Przykład wykorzystania nowej wersji instrukcji <code class="docutils literal notranslate"><span class="pre">if</span></code> w pracy z muteksami:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lk</span><span class="p">{</span><span class="n">mtx</span><span class="p">};</span><span class="w"> </span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Instrukcja <code class="docutils literal notranslate"><span class="pre">switch</span></code> z nową składnią:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Gadget</span><span class="w"> </span><span class="n">g</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">status</span><span class="p">())</span>
<span class="p">{</span>
<span class="k">case</span><span class="w"> </span><span class="no">Status</span><span class="o">::</span><span class="no">on</span><span class="p">:</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Gadget is on&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="k">case</span><span class="w"> </span><span class="no">Status</span><span class="o">::</span><span class="no">off</span><span class="p">:</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Gadget is off&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="k">case</span><span class="w"> </span><span class="no">Status</span><span class="o">::</span><span class="no">bad</span><span class="p">:</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Gadget is broken&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="obiekty-tymczasowe-w-sekcji-inicjujacej">
<h3>Obiekty tymczasowe w sekcji inicjującej<a class="headerlink" href="#obiekty-tymczasowe-w-sekcji-inicjujacej" title="Link to this heading">#</a></h3>
<p>Obiekt tymczasowy utworzony na potrzeby inicjalizacji istnieje tylko w obrębie sekcji inicjującej (tak jak w pętli <code class="docutils literal notranslate"><span class="pre">for</span></code>).</p>
<p>Przykład z <em>bugiem</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span><span class="w"> </span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="c1">// ERROR - locks ends before ;</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Poprawiony kod:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span><span class="w"> </span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="c1">// OK - lock has name</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>lub</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="w"> </span><span class="n">lk</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span><span class="w"> </span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="structured-bindings-i-if-z-sekcja-inicjujaca">
<h3>Structured bindings i if z sekcją inicjującą<a class="headerlink" href="#structured-bindings-i-if-z-sekcja-inicjujaca" title="Link to this heading">#</a></h3>
<p>Instrukcja <code class="docutils literal notranslate"><span class="pre">if</span></code> z sekcją inicjującą może być połączona z przypisaniem wielu wartości do zmiennych za pomocą <em>structured bindings</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dictionary</span><span class="p">;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">was_inserted</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dictionary</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;fourty two&quot;</span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="n">was_inserted</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Inserted new value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Value already exists: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<div class="toctree-wrapper compound">
</div>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="cpp-standards.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Standardy ISO C++</p>
      </div>
    </a>
    <a class="right-next"
       href="constexpr-if.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">constexpr if (C++17)</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nowe-typy-danych-podstawowych">Nowe typy danych podstawowych</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#typy-calkowite-o-znanym-rozmiarze">Typy całkowite o znanym rozmiarze</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nullptr-uniwersalny-pusty-wskaznik">nullptr - uniwersalny pusty wskaźnik</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#raw-string-literals">Raw String Literals</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wsparcie-dla-unicode">Wsparcie dla Unicode</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#typy-lancuchowe">Typy łańcuchowe</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rozszerzone-typy-wyliczeniowe">Rozszerzone typy wyliczeniowe</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#std-underlying-type-t">std::underlying_type_t<enum></enum></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wyliczenia-silnie-typizowane-scoped-enumerations">Wyliczenia silnie typizowane - Scoped Enumerations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deklaracje-zmiennych-z-auto">Deklaracje zmiennych z auto</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iteracja-po-kontenerach-z-auto">Iteracja po kontenerach z auto</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mechanizm-dedukcji-typu-dla-auto">Mechanizm dedukcji typu dla auto</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skladnia-definicji-zmiennych-z-auto">Składnia definicji zmiennych z auto</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#petla-for-dla-zakresow-range-based-for">Pętla for dla zakresów - range-based for</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efektywna-wersja-range-based-for">Efektywna wersja range-based for</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#funkcje-std-begin-i-std-end">Funkcje std::begin() i std::end()</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iteracja-po-kontenerach-zdefiniowanych-przez-uzytkownika">Iteracja po kontenerach zdefiniowanych przez użytkownika</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skladnia-jednolitej-inicjalizacji">Składnia jednolitej inicjalizacji</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inicjalizacja-z-wykorzystaniem">Inicjalizacja z wykorzystaniem {}</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inicjalizacja-dla-agregatow">Inicjalizacja {} dla agregatów</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inicjalizacja-klas-struktur-nie-bedacych-agregatami">Inicjalizacja {} klas/struktur nie będących agregatami</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#konwersja-zawezajaca-typ">Konwersja zawężająca typ</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#listy-inicjalizacyjne">Listy inicjalizacyjne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#klasa-initializer-list-t">Klasa initializer_list&lt;T&gt;</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#listy-inicjalizacyjne-w-przeciazonych-konstruktorach">Listy inicjalizacyjne w przeciążonych konstruktorach</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#listy-inicjalizacyjne-a-dedukcja-typow">Listy inicjalizacyjne a dedukcja typów</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#slowo-kluczowe-decltype">Słowo kluczowe - decltype</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nowa-skladnia-deklaracji-funkcji">Nowa składnia deklaracji funkcji</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#automatyczna-dedukcja-typu-zwracanego-z-funkcji-c-14">Automatyczna dedukcja typu zwracanego z funkcji (C++14)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dedukcja-z-auto">Dedukcja z auto</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dedukcja-z-decltype-auto">Dedukcja z decltype(auto)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#structured-bindings-c-17">Structured bindings (C++17)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#typy-wiazan">Typy wiązań</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mechanizm-wiazania-structured-binding">Mechanizm wiązania structured binding</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kwalifikatory-dla-wiazan">Kwalifikatory dla wiązań</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#praktyczne-wykorzystanie-structured-bindings">Praktyczne wykorzystanie structured bindings</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#instrukcje-if-oraz-switch-z-sekcja-inicjujaca-c-17">Instrukcje if oraz switch z sekcją inicjującą (C++17)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#obiekty-tymczasowe-w-sekcji-inicjujacej">Obiekty tymczasowe w sekcji inicjującej</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#structured-bindings-i-if-z-sekcja-inicjujaca">Structured bindings i if z sekcją inicjującą</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Krystian Piękoś - Infotraining
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>